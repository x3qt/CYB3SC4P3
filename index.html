<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <title>CYB3SC4P3: Firewall Breach</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
    canvas { display: block; }

    #info {
      position: absolute; bottom: 10px; left: 10px; z-index: 100;
      background: rgba(0, 0, 0, 0.8); color: #00ffff; padding: 8px;
      border: 1px solid #00ffff; border-radius: 3px; display: none;
    }
    #reticle {
      position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
      background: radial-gradient(circle, rgba(255, 0, 0, 0.8), transparent);
      border: 1px solid #ff0000; border-radius: 50%; transform: translate(-50%, -50%);
      pointer-events: none; z-index: 100; display: none;
      transition: transform 0.1s;
    }
    #killCount, #health {
      position: absolute; top: 10px; right: 10px; z-index: 100;
      background: rgba(0, 0, 0, 0.8); color: #ff00ff; padding: 8px;
      border: 1px solid #ff00ff; border-radius: 3px; display: none;
    }
    #health { top: 50px; color: #00ff00; border-color: #00ff00; }
    #intro {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 72px; color: #ff0000; text-align: center; z-index: 200; opacity: 1;
      text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000;
    }
    #intro.loading { animation: colorCycle 9s infinite, glitch 0.1s infinite; }
    #intro.loaded { animation: colorCycle 9s infinite; }
    #intro.fade-out { animation: fadeOut 3s forwards; }
    #gameOver {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 48px; color: #ff0000; z-index: 300; display: none;
      background: rgba(0, 0, 0, 0.9); padding: 20px; border: 2px solid #ff0000;
      border-radius: 5px; text-shadow: 0 0 15px #ff0000;
    }
    #message {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      font-size: 24px; color: #ff00ff; z-index: 200; opacity: 0;
      background: rgba(0, 0, 0, 0.8); padding: 10px; border-radius: 5px;
      transition: opacity 0.5s; text-shadow: 0 0 5px #ff00ff;
    }
    #hitIndicator {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255, 0, 0, 0.7); opacity: 0; pointer-events: none; z-index: 150;
    }
    #noiseOverlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      display: none; pointer-events: none; z-index: 250; opacity: 0.5;
    }
    #minimap {
      position: absolute; bottom: 10px; right: 10px; width: 200px; height: 200px;
      border: 2px solid #00ffff; background: rgba(0, 0, 0, 0.8); z-index: 100;
      display: none; overflow: hidden; border-radius: 5px;
    }
    #controls {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; z-index: 10; display: none;
    }
    .joystick, .control-button {
      pointer-events: auto; transition: background 0.2s;
    }
    .joystick {
      position: absolute; bottom: 20px; width: 150px; height: 150px;
      border-radius: 50%; background: rgba(255, 255, 255, 0.2);
      border: 2px solid #00ffff; touch-action: none;
    }
    .joystick.active { background: rgba(255, 255, 255, 0.4); }
    #left-joystick { left: 20px; }
    #right-joystick { right: 20px; }
    .control-button {
      position: absolute; width: 60px; height: 60px; background: rgba(255, 255, 255, 0.2);
      color: #fff; text-align: center; line-height: 60px; border-radius: 50%;
      border: 2px solid #ff00ff; font-size: 18px; touch-action: none;
    }
    .control-button.active { background: rgba(255, 255, 255, 0.4); }
    #fly-button { right: 20px; top: 33%; transform: translateY(-50%); }
    #map-button { left: 20px; top: 33%; transform: translateY(-50%); }
    @keyframes colorCycle {
      0% { filter: hue-rotate(0deg); } 50% { filter: hue-rotate(180deg); } 100% { filter: hue-rotate(360deg); }
    }
    @keyframes fadeOut {
      0% { opacity: 1; } 100% { opacity: 0; }
    }
    @keyframes blink {
      0% { opacity: 0; } 50% { opacity: 0.7; } 100% { opacity: 0; }
    }
    @keyframes glitch {
      0% { transform: translate(-50%, -50%) skew(0deg); }
      20% { transform: translate(-50%, -50%) skew(5deg); }
      40% { transform: translate(-50%, -50%) skew(-5deg); }
      60% { transform: translate(-50%, -50%) skew(3deg); }
      80% { transform: translate(-50%, -50%) skew(-3deg); }
      100% { transform: translate(-50%, -50%) skew(0deg); }
    }
  </style>
</head>
<body>
  <div id="info">WASD to move, Mouse to look, F to fly (costs breaches), Left Click to shoot, M for minimap</div>
  <div id="killCount">BR34CH1NG: 0%</div>
  <div id="health">C0NN3CT10N: 100%</div>
  <div id="intro">1NT3RC3PT1NG C0NN3CT10N...</div>
  <div id="gameOver">C0NN3CT10N L05T</div>
  <div id="message"></div>
  <div id="hitIndicator"></div>
  <div id="reticle"></div>
  <canvas id="noiseOverlay"></canvas>
  <canvas id="minimap"></canvas>
  <div id="controls">
    <div id="left-joystick" class="joystick"></div>
    <div id="right-joystick" class="joystick"></div>
    <div id="map-button" class="control-button">Map</div>
    <div id="fly-button" class="control-button">Fly</div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/geometries/TextGeometry.js"></script>
  <script>
    // Core Setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x040348);
    scene.fog = new THREE.FogExp2(0x040348, 0.002); // Fog for depth
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    camera.rotation.order = 'YXZ';
    const birdCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
    birdCamera.rotation.order = 'YXZ';
    const minimapCamera = new THREE.OrthographicCamera(-100, 100, 100, -100, 0, 1000);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance boost
    document.body.appendChild(renderer.domElement);

    const minimapRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    minimapRenderer.setSize(200, 200);
    document.getElementById('minimap').replaceWith(minimapRenderer.domElement);
    minimapRenderer.domElement.id = 'minimap';

    // Lighting
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(100, 100, 100);
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(directionalLight, ambientLight);

    // Ground and Sun
    const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
    const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x080808, side: THREE.DoubleSide });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, fog: false });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    sun.position.set(500, 500, -1000);
    scene.add(sun);

    // Game State
    const playerHeight = 4;
    const playerRadius = 0.25;
    let playerHealth = 100;
    let killCount = 0;
    let isDead = false;
    let isVictorious = false;
    let sceneLoaded = false;
    let birdViewActive = false;
    let isFreeFly = false;
    const carsToBreach = 45;

    // Constants
    const moveSpeed = 1.35;
    const carSpeed = 1.35;
    const pedestrianSpeed = 0.45;
    const angryPedestrianSpeed = 0.75;
// Game parameters and configuration
const config = {
  airplaneSpeed: 0.9,
  numCars: 120,
  numPedestrians: 150,
  numAirplanes: 15,
  pedestrian: {
    accuracy: 0.15,
    alertDistance: 120,
    shootingInterval: 30,
    shootingRange: 120
  },
  carExplosionRadius: 30,
  wall: {
    height: 450,
    enableAnimation: true,
    particleDensity: 4
  }
};

// Utility function for random selection
function randomFromArray(array) {
  return array[Math.floor(Math.random() * array.length)];
}

// Neon ads spawning function (optimized and error-proofed)
function spawnNeonAdsByBuildings(buildings, scene, font, brandNames, cyberpunkColors, neonAds) {
  if (!font) {
    console.warn('Font not loaded, neon ads skipped.');
    return;
  }

  buildings.forEach(building => {
    const box = building.userData.box;
    if (!box) return;

    const center = box.getCenter(new THREE.Vector3());
    const size = box.getSize(new THREE.Vector3());
    const textSize = Math.max(3, size.x / 20);

    const brand = randomFromArray(brandNames);
    const textGeo = new THREE.TextGeometry(brand, {
      font: font,
      size: textSize,
      height: textSize / 3,
      curveSegments: 4 // Enhanced curve segments for better visuals
    });

    textGeo.center();
    textGeo.computeBoundingBox();

    const halfHeight = textGeo.boundingBox.max.y;
    const adPosition = new THREE.Vector3(center.x, box.max.y + halfHeight + 10, center.z);

    const emissiveColor = randomFromArray(cyberpunkColors);
    const textMaterial = new THREE.MeshPhongMaterial({
      color: emissiveColor,
      emissive: emissiveColor,
      emissiveIntensity: 1.2 // Enhanced for better neon effect
    });

    const textMesh = new THREE.Mesh(textGeo, textMaterial);
    textMesh.position.copy(adPosition);
    textMesh.rotation.y = Math.random() * Math.PI * 2;

    scene.add(textMesh);
    neonAds.push(textMesh);
  });
}

// Overpass API query (formatted and easier to update bounds)
const overpassBounds = {
  south: 53.894109,
  west: 27.541987,
  north: 53.907147,
  east: 27.570987
};

const overpassQuery = `
[out:json][timeout:25];
(
  way["highway"](${overpassBounds.south},${overpassBounds.west},${overpassBounds.north},${overpassBounds.east});
  way["building"](${overpassBounds.south},${overpassBounds.west},${overpassBounds.north},${overpassBounds.east});
  way["waterway"](${overpassBounds.south},${overpassBounds.west},${overpassBounds.north},${overpassBounds.east});
);
(._;>;);
out body;
`;

// Intro loading animation (optimized and encapsulated)
const introLoader = {
  interval: null,
  dotCount: 1,
  start(introDiv) {
    if (!introDiv) {
      console.error('Intro div not found.');
      return;
    }
    introDiv.classList.add('loading');
    this.interval = setInterval(() => {
      this.dotCount = (this.dotCount % 3) + 1;
      introDiv.innerText = `1NT3RC3PT1NG C0NN3CT10N${'.'.repeat(this.dotCount)}`;
    }, 500);
  },
  stop(introDiv) {
    clearInterval(this.interval);
    introDiv.classList.remove('loading');
    introDiv.innerText = '';
  }
};

// Initialize scene-loaded flag
let sceneLoaded = false;

// Usage Example (call this once your assets are ready):
// introLoader.start(document.getElementById('intro'));
// After loading complete:
// introLoader.stop(document.getElementById('intro'));
// sceneLoaded = true;


    // Entities
    let buildings = [], roads = [], cars = [], pedestrians = [], neonAds = [], explosions = [], airplanes = [], walls = [];
    let wallParticleSystems = [];
    let cityBounds = new THREE.Box3();

    // Weather System
    let rainParticles = null;
    let isRaining = false;
    function toggleRain() {
      if (!rainParticles) {
        const particleCount = 5000;
        const positions = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
          positions[i * 3] = (Math.random() - 0.5) * 2000;
          positions[i * 3 + 1] = Math.random() * 1000;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
        }
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ccff, size: 0.5, transparent: true });
        rainParticles = new THREE.Points(geometry, material);
        scene.add(rainParticles);
      }
      isRaining = !isRaining;
      rainParticles.visible = isRaining;
      directionalLight.intensity = isRaining ? 0.5 : 1;
      ambientLight.intensity = isRaining ? 0.3 : 0.5;
    }

    // Font Loading
    let font = null;
    const fontLoader = new THREE.FontLoader();
    fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.167.1/examples/fonts/droid/droid_sans_regular.typeface.json',
      (loadedFont) => { font = loadedFont; spawnNeonAdsByBuildings(); },
      undefined,
      (error) => console.error("Font loading failed:", error)
    );

    // Overpass API Query
    const baseLat = 53.89, baseLon = 27.55;
    const metersPerLat = 111320, metersPerLon = 111320 * Math.cos(baseLat * Math.PI / 180);
    function latLonToXY(lat, lon) {
      const x = (lon - baseLon) * metersPerLon;
      const y = (lat - baseLat) * metersPerLat;
      return { x: -x, y };
    }

    const overpassQuery = `[out:json][timeout:25];
      (way["highway"](53.894109,27.541987,53.907147,27.570987);
      way["building"](53.894109,27.541987,53.907147,27.570987);
      way["waterway"](53.894109,27.541987,53.907147,27.570987););(._;>;);out body;`;

    // Scene Initialization
    function initScene() {
      fetch("https://overpass-api.de/api/interpreter", { method: "POST", body: overpassQuery })
        .then(response => response.json())
        .then(data => {
          const nodes = {};
          data.elements.forEach(el => { if (el.type === "node") nodes[el.id] = el; });
          data.elements.forEach(el => {
            if (el.type === "way" && el.nodes) {
              const points = el.nodes.map(id => {
                const node = nodes[id];
                return node ? new THREE.Vector3(...Object.values(latLonToXY(node.lat, node.lon)), 0) : null;
              }).filter(p => p);
              if (el.tags) processWay(el.tags, points);
            }
          });
          finalizeScene();
        })
        .catch(err => console.error("Overpass API error:", err));
    }

    function processWay(tags, points) {
      const isClosed = points.length > 2 && points[0].distanceTo(points[points.length - 1]) < 1;
      if (tags.highway) {
        const streetMaterial = new THREE.LineBasicMaterial({ color: 0x111111 });
        const street = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), streetMaterial);
        street.position.y = 0.01;
        scene.add(street);
        const neon = new THREE.Line(street.geometry.clone(), new THREE.LineBasicMaterial({ color: cyberpunkColors[Math.floor(Math.random() * cyberpunkColors.length)] }));
        neon.position.y = 0.02;
        scene.add(neon);
        roads.push({ points, name: tags.name || "" });
        if (tags.name && font) addRoadLabel(points, tags.name);
      } else if (tags.building && isClosed) {
        const shape = new THREE.Shape(points.map(p => new THREE.Vector2(p.x, p.z)));
        const height = 25 + Math.random() * 50;
        const building = new THREE.Mesh(
          new THREE.ExtrudeGeometry(shape, { steps: 1, depth: height, bevelEnabled: false }),
          new THREE.MeshPhongMaterial({ color: 0x111111, emissive: 0x6600ff, emissiveIntensity: 0.5 })
        );
        building.rotation.x = Math.PI / 2;
        building.position.y = height;
        scene.add(building);
        buildings.push(building);
        building.userData.box = new THREE.Box3().setFromObject(building);
        cityBounds.union(building.userData.box);
      } else if (tags.waterway) {
        const river = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(points),
          new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 15 })
        );
        scene.add(river);
      }
    }

    function addRoadLabel(points, name) {
      const midPoint = points[Math.floor(points.length / 2)];
      const text = new THREE.Mesh(
        new THREE.TextGeometry(name, { font, size: 1, height: 0.5 }),
        new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.7 })
      );
      text.position.set(midPoint.x, 0.02, midPoint.z);
      scene.add(text);
    }

    function finalizeScene() {
      spawnCityWalls();
      spawnEntities();
      const cityCenter = cityBounds.getCenter(new THREE.Vector3());
      camera.position.copy(findSafeSpawnPosition(cityCenter));
      sceneLoaded = true;
      transitionIntro();
    }

    function spawnCityWalls() {
      const wallMaterial = new THREE.MeshBasicMaterial({ visible: false });
      const wallBuffer = 10, wallHeight = 450;
      const xSize = cityBounds.max.x - cityBounds.min.x + wallBuffer * 2;
      const zSize = cityBounds.max.z - cityBounds.min.z + wallBuffer * 2;

      const wallsData = [
        { geo: new THREE.BoxGeometry(xSize, wallHeight, 5), pos: [0, wallHeight / 2, cityBounds.max.z + wallBuffer], dir: 'x' },
        { geo: new THREE.BoxGeometry(xSize, wallHeight, 5), pos: [0, wallHeight / 2, cityBounds.min.z - wallBuffer], dir: 'x' },
        { geo: new THREE.BoxGeometry(5, wallHeight, zSize), pos: [cityBounds.max.x + wallBuffer, wallHeight / 2, 0], dir: 'z' },
        { geo: new THREE.BoxGeometry(5, wallHeight, zSize), pos: [cityBounds.min.x - wallBuffer, wallHeight / 2, 0], dir: 'z' }
      ];

      wallsData.forEach(data => {
        const wall = new THREE.Mesh(data.geo, wallMaterial);
        wall.position.set(...data.pos);
        scene.add(wall);
        buildings.push(wall);
        walls.push(wall);
        addWallParticles(wall, data.dir);
      });
    }

    function addWallParticles(wall, direction) {
      const particleCount = Math.floor((direction === 'x' ? wall.geometry.parameters.width : wall.geometry.parameters.depth) / 5) * 4;
      const positions = new Float32Array(particleCount * 3);
      const speeds = new Float32Array(particleCount);
      for (let i = 0; i < particleCount; i++) {
        const baseX = direction === 'x' ? wall.position.x - wall.geometry.parameters.width / 2 + (i % (particleCount / 4)) * 5 : wall.position.x;
        const baseZ = direction === 'z' ? wall.position.z - wall.geometry.parameters.depth / 2 + (i % (particleCount / 4)) * 5 : wall.position.z;
        positions[i * 3] = baseX + (Math.random() - 0.5) * 2;
        positions[i * 3 + 1] = Math.random() * wallHeight;
        positions[i * 3 + 2] = baseZ + (Math.random() - 0.5) * 2;
        speeds[i] = 1 + Math.random() * 2;
      }
      const system = new THREE.Points(
        new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(positions, 3)),
        new THREE.PointsMaterial({ color: 0xffff99, size: 0.5 })
      );
      system.userData.speeds = speeds;
      scene.add(system);
      wallParticleSystems.push(system);
    }

    function spawnEntities() {
      spawnCars();
      spawnPedestrians();
      spawnAirplanes();
      if (font) spawnNeonAdsByBuildings();
    }

    function spawnCars() {
      for (let i = 0; i < numCars; i++) {
        const road = roads[Math.floor(Math.random() * roads.length)];
        if (road.points.length < 2) continue;
        const idx = Math.floor(Math.random() * (road.points.length - 1));
        const pos = road.points[idx];
        const car = new THREE.Mesh(
          new THREE.BoxGeometry(9, 4.5, 4.5).translate(0, 2.25, 0),
          new THREE.MeshPhongMaterial({ color: 0x0a0a1a, emissive: cyberpunkColors[Math.floor(Math.random() * cyberpunkColors.length)], emissiveIntensity: 0.8 })
        );
        car.position.set(pos.x, 0, pos.z);
        car.userData = { type: "car", road, currentIndex: idx, dir: Math.random() < 0.5 ? 1 : -1, speed: carSpeed + Math.random() * 0.5, bounceVelocity: new THREE.Vector3() };
        updateCarRotation(car);
        scene.add(car);
        cars.push(car);
      }
    }

    function spawnPedestrians() {
      const pedGeometry = {
        torso: new THREE.CylinderGeometry(0.6, 0.8, 2.5, 8).translate(0, 1.25, 0),
        head: new THREE.SphereGeometry(0.5, 12, 12),
        eye: new THREE.SphereGeometry(0.1, 8, 8),
        armUpper: new THREE.CylinderGeometry(0.25, 0.25, 1.25, 8),
        armLower: new THREE.CylinderGeometry(0.2, 0.2, 1.25, 8),
        legUpper: new THREE.CylinderGeometry(0.35, 0.35, 1.5, 8),
        legLower: new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8)
      };

      for (let i = 0; i < numPedestrians; i++) {
        const road = roads[Math.floor(Math.random() * roads.length)];
        if (road.points.length < 2) continue;
        const pos = road.points[Math.floor(Math.random() * (road.points.length - 1))];
        const ped = createPedestrian(pos, pedGeometry);
        scene.add(ped);
        pedestrians.push(ped);
      }
    }

    function createPedestrian(pos, geo) {
      const bodyColor = [0x111133, 0x222244, 0x333355][Math.floor(Math.random() * 3)];
      const headColor = [0xffcc99, 0xffaa77, 0xffddaa][Math.floor(Math.random() * 3)];
      const torso = new THREE.Mesh(geo.torso, new THREE.MeshPhongMaterial({ color: bodyColor, emissive: 0x222255, emissiveIntensity: 0.8 }));
      torso.position.set(pos.x, 2.25, pos.z);

      const head = new THREE.Mesh(geo.head, new THREE.MeshPhongMaterial({ color: headColor }));
      head.position.set(0, 2.5, 0);
      torso.add(head);

      const eyeMat = new THREE.MeshBasicMaterial({ color: cyberpunkColors[Math.floor(Math.random() * cyberpunkColors.length)], transparent: true, opacity: 0.7 });
      const eyes = [new THREE.Mesh(geo.eye, eyeMat), new THREE.Mesh(geo.eye, eyeMat)];
      eyes[0].position.set(0.15, 0.25, 0.3);
      eyes[1].position.set(-0.15, 0.25, 0.3);
      head.add(...eyes);

      const limbs = [
        { geo: geo.armUpper, pos: [0.7, 1.25, 0], isArm: true, isLeft: true },
        { geo: geo.armLower, pos: [0, -1.25, 0], parent: 0 },
        { geo: geo.armUpper, pos: [-0.7, 1.25, 0], isArm: true, isLeft: false },
        { geo: geo.armLower, pos: [0, -1.25, 0], parent: 2 },
        { geo: geo.legUpper, pos: [0.35, -0.5, 0], isLeg: true, isLeft: true },
        { geo: geo.legLower, pos: [0, -1.5, 0], parent: 4 },
        { geo: geo.legUpper, pos: [-0.35, -0.5, 0], isLeg: true, isLeft: false },
        { geo: geo.legLower, pos: [0, -1.5, 0], parent: 6 }
      ];
      limbs.forEach((limb, i) => {
        const mesh = new THREE.Mesh(limb.geo, new THREE.MeshPhongMaterial({ color: bodyColor }));
        mesh.position.set(...limb.pos);
        if (limb.isArm || limb.isLeg) mesh.userData = { isArm: limb.isArm, isLeg: limb.isLeg, isLeft: limb.isLeft };
        if (limb.parent !== undefined) limbs[limb.parent].add(mesh);
        else torso.add(mesh);
      });

      torso.userData = { type: "pedestrian", dir: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(), speed: pedestrianSpeed, walkCycle: 0, isAngry: false, shootTimer: 0, radius: 1, bounceVelocity: new THREE.Vector3() };
      return torso;
    }

    function spawnAirplanes() {
      const airplaneGeo = new THREE.BoxGeometry(4, 2, 10);
      for (let i = 0; i < numAirplanes; i++) {
        const airplane = new THREE.Mesh(airplaneGeo, new THREE.MeshPhongMaterial({ color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 0.9 }));
        airplane.position.set(
          cityBounds.min.x + Math.random() * (cityBounds.max.x - cityBounds.min.x),
          300,
          cityBounds.min.z + Math.random() * (cityBounds.max.z - cityBounds.min.z)
        );
        airplane.rotation.y = Math.random() * Math.PI * 2;
        airplane.userData = { type: "airplane", speed: airplaneSpeed + Math.random(), direction: new THREE.Vector3(Math.sin(airplane.rotation.y), 0, Math.cos(airplane.rotation.y)) };
        scene.add(airplane);
        airplanes.push(airplane);
      }
    }

    function spawnNeonAdsByBuildings() {
      const brandNames = ["NeonCorp", "CyberPulse", "SynthWave", "TechNoir", "GlowGrid"];
      buildings.forEach(building => {
        if (!building.userData.box) return;
        const center = building.userData.box.getCenter(new THREE.Vector3());
        const size = building.userData.box.getSize(new THREE.Vector3());
        const text = new THREE.Mesh(
          new THREE.TextGeometry(brandNames[Math.floor(Math.random() * brandNames.length)], { font, size: size.x / 20, height: 1 }),
          new THREE.MeshPhongMaterial({ color: cyberpunkColors[Math.floor(Math.random() * cyberpunkColors.length)], emissiveIntensity: 1 })
        );
        text.position.set(center.x, building.userData.box.max.y + 10, center.z);
        text.rotation.y = Math.random() * Math.PI * 2;
        scene.add(text);
        neonAds.push(text);
      });
    }

    // UI Updates
    function updateKillCount() {
      const percentage = Math.min(100, Math.floor((killCount / carsToBreach) * 100));
      document.getElementById("killCount").innerText = `BR34CH1NG: ${percentage}%`;
      if (percentage >= 100 && !isDead && !isVictorious) showVictoryScreen();
    }

    function transitionIntro() {
      const intro = document.getElementById('intro');
      let dotCount = 1;
      const dotCycle = setInterval(() => {
        dotCount = (dotCount % 3) + 1;
        intro.innerText = "1NT3RC3PT1NG C0NN3CT10N" + ".".repeat(dotCount);
      }, 500);
      setTimeout(() => {
        clearInterval(dotCycle);
        intro.classList.remove('loading');
        intro.style.display = 'none';
        showMessage("C0NN3CT3D", 1000, () => {
          intro.innerText = "CYB3SC4P3";
          intro.style.display = 'block';
          intro.classList.add('loaded', 'fade-out');
          setTimeout(() => {
            intro.style.display = 'none';
            showMessage("Objective: Breach data transport to hack firewall", 5000, () => {
              document.getElementById('info').style.display = isMobile ? 'none' : 'block';
              document.getElementById('killCount').style.display = 'block';
              document.getElementById('health').style.display = 'block';
              document.getElementById('controls').style.display = isMobile ? 'block' : 'none';
              updateReticleVisibility();
            });
          }, 3000);
        });
      }, 2000);
    }

    function showMessage(text, duration = 3000, callback) {
      const msg = document.getElementById('message');
      msg.innerText = text;
      msg.style.opacity = '1';
      setTimeout(() => { msg.style.opacity = '0'; if (callback) callback(); }, duration);
    }

    // Game Logic
    function findSafeSpawnPosition(center) {
      let pos = center.clone();
      pos.y = playerHeight;
      for (let i = 0; i < 50; i++) {
        const ray = new THREE.Raycaster(pos, new THREE.Vector3(0, -1, 0));
        const intersects = ray.intersectObjects(buildings);
        if (intersects.length === 0 || intersects[0].distance > playerHeight) return pos;
        pos.x += (Math.random() - 0.5) * 20;
        pos.z += (Math.random() - 0.5) * 20;
      }
      return pos;
    }

    function checkCollisions(currentPos, nextPos, radius = playerRadius) {
      const direction = nextPos.clone().sub(currentPos).normalize();
      const ray = new THREE.Raycaster(currentPos, direction, 0, currentPos.distanceTo(nextPos) + radius);
      const intersects = ray.intersectObjects(buildings);
      if (intersects.length > 0 && intersects[0].distance <= currentPos.distanceTo(nextPos)) {
        const normal = intersects[0].face.normal.clone().applyQuaternion(intersects[0].object.quaternion).normalize();
        const slide = nextPos.clone().sub(currentPos).projectOnPlane(normal);
        return currentPos.clone().add(slide);
      }
      return nextPos;
    }

    function shoot() {
      if (!sceneLoaded || isDead || isVictorious || birdViewActive) return;
      playLaserSound();
      const origin = camera.position.clone().add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(-1));
      const ray = new THREE.Raycaster(origin, camera.getWorldDirection(new THREE.Vector3()));
      const targets = cars.concat(pedestrians);
      const intersects = ray.intersectObjects(targets.concat(buildings));
      
      let hit = intersects[0];
      if (!hit) return;
      const endPoint = hit.point;
      createLaser(origin, endPoint);

      if (hit.object.userData.type === "car") {
        killCount++;
        updateKillCount();
        createExplosion(hit.object.position);
        scene.remove(hit.object);
        cars.splice(cars.indexOf(hit.object), 1);
      } else if (hit.object.userData.type === "pedestrian") {
        createExplosion(hit.object.position, 2);
        scene.remove(hit.object);
        pedestrians.splice(pedestrians.indexOf(hit.object), 1);
        playerHealth = Math.min(100, playerHealth + 1);
        updateHealth();
      }
    }

    function createLaser(start, end) {
      const direction = end.clone().sub(start).normalize();
      const length = start.distanceTo(end);
      const laser = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.2, length, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 })
      );
      laser.position.copy(start.clone().add(direction.multiplyScalar(length / 2)));
      laser.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction);
      scene.add(laser);
      setTimeout(() => scene.remove(laser), 100);
    }

    function createExplosion(pos, scale = 5) {
      const explosion = new THREE.Mesh(
        new THREE.SphereGeometry(scale, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 })
      );
      explosion.position.copy(pos);
      explosion.userData.startTime = performance.now();
      scene.add(explosion);
      explosions.push(explosion);
      playExplosionSound();
    }

    function updateEntities() {
      cars.forEach(car => {
        const road = car.userData.road;
        let idx = car.userData.currentIndex;
        const dir = car.userData.dir;
        const nextIdx = idx + dir;
        if (nextIdx >= 0 && nextIdx < road.points.length) {
          const target = road.points[nextIdx];
          const move = target.clone().sub(car.position).normalize().multiplyScalar(carSpeed);
          car.position.add(move);
          if (car.position.distanceTo(target) < 2) car.userData.currentIndex = nextIdx;
          updateCarRotation(car);
        } else {
          car.userData.dir *= -1;
          updateCarRotation(car);
        }
        car.position.y = 0;
      });

      pedestrians.forEach(ped => {
        const move = ped.userData.isAngry ? camera.position.clone().sub(ped.position).normalize() : ped.userData.dir.clone();
        const nextPos = ped.position.clone().add(move.multiplyScalar(ped.userData.speed));
        ped.position.copy(checkCollisions(ped.position, nextPos, ped.userData.radius));
        ped.lookAt(nextPos.x, ped.position.y, nextPos.z);
        ped.userData.walkCycle += ped.userData.speed;
        const swing = Math.sin(ped.userData.walkCycle);
        ped.children.forEach(child => {
          if (child.userData.isArm) child.rotation.x = child.userData.isLeft ? -swing * 0.5 : swing * 0.5;
          if (child.userData.isLeg) child.rotation.x = child.userData.isLeft ? swing * 0.5 : -swing * 0.5;
        });
      });

      airplanes.forEach(plane => {
        plane.position.add(plane.userData.direction.clone().multiplyScalar(plane.userData.speed));
        if (plane.position.x < cityBounds.min.x || plane.position.x > cityBounds.max.x ||
            plane.position.z < cityBounds.min.z || plane.position.z > cityBounds.max.z) {
          plane.userData.direction.multiplyScalar(-1);
          plane.rotation.y += Math.PI;
        }
        plane.position.y = 300;
      });

      if (isRaining && rainParticles) {
        const positions = rainParticles.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] -= 2;
          if (positions[i + 1] < 0) positions[i + 1] = 1000;
        }
        rainParticles.geometry.attributes.position.needsUpdate = true;
      }
    }

    // Audio
    const audioCtx = new AudioContext();
    let activeOscillators = [];
    function playLaserSound() {
      const osc = audioCtx.createOscillator();
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.8, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.2);
      activeOscillators.push(osc);
    }

    function playExplosionSound() {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.5, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.5));
      const source = audioCtx.createBufferSource();
      source.buffer = buffer;
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
      source.connect(gain).connect(audioCtx.destination);
      source.start();
      activeOscillators.push(source);
    }

    // Controls
    const isMobile = 'ontouchstart' in window;
    const keys = {};
    let yaw = 0, pitch = 0;
    const rotationSpeed = 0.003;
    const movementDir = new THREE.Vector2();
    const lookDir = new THREE.Vector2();

    document.addEventListener('keydown', e => {
      if (!sceneLoaded || isDead || isVictorious) return;
      keys[e.key.toLowerCase()] = true;
      if (e.key.toLowerCase() === 'f' && killCount > 0) toggleFly();
      if (e.key.toLowerCase() === 'm') toggleBirdView();
      if (e.key.toLowerCase() === 'r') toggleRain();
    });
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    document.addEventListener('mousedown', e => { if (e.button === 0) shoot(); });
    document.addEventListener('mousemove', e => {
      if (document.pointerLockElement === document.body) {
        yaw -= e.movementX * rotationSpeed;
        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch - e.movementY * rotationSpeed));
        camera.rotation.set(pitch, yaw, 0);
      }
    });
    document.addEventListener('click', () => document.body.requestPointerLock());

    if (isMobile) {
      const joysticks = { left: document.getElementById('left-joystick'), right: document.getElementById('right-joystick') };
      const buttons = { fly: document.getElementById('fly-button'), map: document.getElementById('map-button') };
      let touches = {};

      function updateJoystick(touch, joystick, dir) {
        const rect = joystick.getBoundingClientRect();
        const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
        const dx = touch.clientX - center.x, dy = touch.clientY - center.y;
        const dist = Math.min(Math.sqrt(dx * dx + dy * dy) / (rect.width / 2), 1);
        const angle = Math.atan2(dy, dx);
        dir.set(Math.cos(angle) * dist, -Math.sin(angle) * dist);
        joystick.classList.toggle('active', dist > 0);
      }

      document.addEventListener('touchstart', e => {
        e.preventDefault();
        for (const touch of e.changedTouches) {
          if (!touches.left && joysticks.left.contains(touch.target)) touches.left = touch.identifier;
          else if (!touches.right && joysticks.right.contains(touch.target)) touches.right = touch.identifier;
          else if (!touches.fly && buttons.fly.contains(touch.target)) { toggleFly(); touches.fly = touch.identifier; }
          else if (!touches.map && buttons.map.contains(touch.target)) { toggleBirdView(); touches.map = touch.identifier; }
        }
      }, { passive: false });

      document.addEventListener('touchmove', e => {
        e.preventDefault();
        for (const touch of e.touches) {
          if (touch.identifier === touches.left) updateJoystick(touch, joysticks.left, movementDir);
          if (touch.identifier === touches.right) updateJoystick(touch, joysticks.right, lookDir);
        }
      }, { passive: false });

      document.addEventListener('touchend', e => {
        e.preventDefault();
        for (const touch of e.changedTouches) {
          if (touch.identifier === touches.left) { movementDir.set(0, 0); touches.left = null; joysticks.left.classList.remove('active'); }
          if (touch.identifier === touches.right) { lookDir.set(0, 0); touches.right = null; joysticks.right.classList.remove('active'); shoot(); }
          if (touch.identifier === touches.fly) touches.fly = null;
          if (touch.identifier === touches.map) touches.map = null;
        }
      }, { passive: false });
    }

    function toggleFly() {
      if (killCount <= 0) return showMessage("Insufficient breaches for flight");
      isFreeFly = !isFreeFly;
      if (!isFreeFly) { camera.position.y = playerHeight; pitch = 0; camera.rotation.x = 0; }
      document.getElementById('fly-button').classList.toggle('active', isFreeFly);
      updateReticleVisibility();
    }

    function toggleBirdView() {
      birdViewActive = !birdViewActive;
      document.getElementById('map-button').classList.toggle('active', birdViewActive);
      document.getElementById('minimap').style.display = birdViewActive ? 'block' : 'none';
      updateReticleVisibility();
    }

    function updateReticleVisibility() {
      document.getElementById('reticle').style.display = sceneLoaded && !isDead && !isVictorious && !birdViewActive ? 'block' : 'none';
    }

    function updateHealth() {
      document.getElementById('health').innerText = `C0NN3CT10N: ${playerHealth}%`;
      if (playerHealth <= 0 && !isDead) showDeathScreen();
    }

    function showDeathScreen() {
      isDead = true;
      birdViewActive = true;
      document.getElementById('gameOver').style.display = 'block';
      document.getElementById('reticle').style.display = 'none';
      if (isMobile) document.getElementById('controls').style.display = 'none';
      document.getElementById('noiseOverlay').style.display = 'block';
    }

    function showVictoryScreen() {
      isVictorious = true;
      birdViewActive = true;
      const gameOver = document.getElementById('gameOver');
      gameOver.innerText = "F1R3W4LL BR34CH3D";
      gameOver.style.color = '#00ff00';
      gameOver.style.borderColor = '#00ff00';
      gameOver.style.display = 'block';
      document.getElementById('reticle').style.display = 'none';
      if (isMobile) document.getElementById('controls').style.display = 'none';
      cars.forEach(car => createExplosion(car.position));
      cars = [];
    }

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      if (sceneLoaded && !isDead && !isVictorious) {
        updateEntities();
        const forward = camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(moveSpeed);
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(moveSpeed);
        let move = new THREE.Vector3();

        if (isFreeFly) {
          if (isMobile) move.add(forward.multiplyScalar(movementDir.y)).add(right.multiplyScalar(movementDir.x));
          else {
            if (keys['w']) move.add(forward);
            if (keys['s']) move.sub(forward);
            if (keys['a']) move.sub(right);
            if (keys['d']) move.add(right);
          }
          if (move.length() > 0) {
            killCount = Math.max(0, killCount - 0.01);
            updateKillCount();
            if (killCount <= 0) toggleFly();
          }
        } else {
          forward.y = 0; right.y = 0;
          if (isMobile) move.add(forward.multiplyScalar(movementDir.y)).add(right.multiplyScalar(movementDir.x));
          else {
            if (keys['w']) move.add(forward);
            if (keys['s']) move.sub(forward);
            if (keys['a']) move.sub(right);
            if (keys['d']) move.add(right);
          }
        }

        if (move.length() > 0) {
          const nextPos = camera.position.clone().add(move);
          camera.position.copy(checkCollisions(camera.position, nextPos));
          if (!isFreeFly) camera.position.y = playerHeight;
        }

        if (isMobile) {
          yaw -= lookDir.x * 0.1;
          pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch + lookDir.y * 0.1));
          camera.rotation.set(pitch, yaw, 0);
        }

        // Render
        renderer.render(scene, birdViewActive ? birdCamera : camera);
        if (birdViewActive) {
          const center = cityBounds.getCenter(new THREE.Vector3());
          minimapCamera.position.set(center.x, 500, center.z);
          minimapCamera.lookAt(center);
          minimapRenderer.render(scene, minimapCamera);
        }
      } else if (isDead || isVictorious) {
        renderer.render(scene, birdCamera);
      }
    }

    initScene();
    animate();

    // Event Listeners
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      birdCamera.aspect = window.innerWidth / window.innerHeight;
      birdCamera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      minimapRenderer.setSize(200, 200);
      if (isDead) document.getElementById('noiseOverlay').style.display = 'block';
    });
  </script>
</body>
</html>
